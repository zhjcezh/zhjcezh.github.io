---
layout:     post
title:      "数据库/mysql"
subtitle:   ""
date:       2019-08-27 14:00:00
author:     "Cfeng"
header-img: "img/home-bg-o.jpg"
catalog: true
tags:
- 数据库
---
事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚      
        
## ACID
1. 原子性（Atomicity）       
事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。         
回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。        

2. 一致性（Consistency）        
数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。       

3. 隔离性（Isolation）        
一个事务所做的修改在最终提交以前，对其它事务是不可见的。      

4. 持久性（Durability）        
一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。      
使用重做日志来保证持久性。      

* 只有满足一致性，事务的执行结果才是正确的。
* 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
* 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
* 事务满足持久化是为了能应对数据库崩溃的情况。

## 并发一致性问题    
**丢失修改**      
T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。      
    
**读脏数据**      
T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。
    
**不可重复读**    
T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。     
     
**幻影读**      
T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。    
       
产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。       
      
       
## 封锁
**封锁粒度**     
MySQL 中提供了两种封锁粒度：行级锁以及表级锁。     
应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。    
但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。    
在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。         
      
**封锁类型**       
1. 读写锁  
    * 排它锁（Exclusive），简写为 X 锁，又称写锁。    
    * 共享锁（Shared），简写为 S 锁，又称读锁。    
2. 意向锁     
意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。        
     
3. 封锁协议       
    * 三级封锁协议   
        1. 一级封锁协议: 事务 T 要修改数据 A 时必须加 **X 锁**，直到 T 结束才释放锁。       
        2. 二级封锁协议: 在一级的基础上，要求读取数据 A 时必须加 S 锁，**读取完马上释放 S 锁**   
        3. 三级封锁协议: 在二级的基础上，要求读取数据 A 时必须加 S 锁，**直到事务结束**了才能释放 S 锁。      
    
    * 两段锁协议      
    加锁和解锁分为两个阶段进行。     
    事务遵循两段锁协议是保证可串行化调度的充分条件    
    
4. Mysql隐式锁定   
MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。      
    
## 隔离级别    
未提交读（READ UNCOMMITTED）   
事务中的修改，即使没有提交，对其它事务也是可见的。     

提交读（READ COMMITTED）   
一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。      

可重复读（REPEATABLE READ）    
保证在同一个事务中多次读取同样数据的结果是一样的。     

可串行化（SERIALIZABLE）      
强制事务串行执行。需要加锁，其他通常不需要。         
    
## 多版本并发控制
多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。     
   
## Next-Key Locks
Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。     
MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。       
   
## 范式   
1. 第一范式 (1NF)
属性不可分。

2. 第二范式 (2NF)
每个非主属性完全函数依赖于键码。
可以通过分解来满足。    
    
3. 第三范式 (3NF)
   非主属性不传递函数依赖于键码。    
    
    
## MySQL     
关系型数据库，开源免费，**MySQL的默认端口号是3306**    

1. MySQL 索引    
    * B+Tree 索引： 是大多数 MySQL 存储引擎的默认索引类型。只需要对树进行搜索即可，所以查找速度快很多     
    * 哈希索引： 哈希索引能以 O(1) 时间进行查找，但是失去了有序性：无法用于排序与分组；只支持精确查找，无法用于部分查找和范围查找。     
    * 全文索引： 用于查找文本中的关键词     
    * 空间数据索引：    
       
2. 索引优化     
    * 独立的列： 在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引      
    * 多列索引： 在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好        
    * 索引列的顺序： 让选择性最强的索引列放在前面。索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。           
    * 前缀索引： 对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。             
        
**索引的优点：**
大大减少了服务器需要扫描的数据行数。     
帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。     
将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。     
      
**索引的使用条件**
对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；    
对于中到大型的表，索引就非常有效；     
但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。         

**索引设计规范**        
    1. 限制每张表上的索引数量,建议单张表索引不超过 5 个      
    2. 禁止给表中的每一列都建立单独的索引     
    3. 每个 Innodb 表必须有个主键     

3. 查询性能优化    
**优化数据访问**      
    1. 减少请求的数据量   
        * 只返回必要的列：最好不要使用 SELECT * 语句。  
        * 只返回必要的行：使用 LIMIT 语句来限制返回的数据。    
        * 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。    
    
    2. 减少服务器端扫描的行数     
        * 最有效的方式是使用索引来覆盖查询。      
**重构查询方式**    
    1. 切分大查询： 一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。      
    2. 分解大连接查询： 将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联


_执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用_



4. 存储引擎     
**InnoDB**        
是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎         
实现了四个标准的隔离级别      
主索引是聚簇索引     
支持真正的在线热备份     
     
**MyISAM**      
设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。    
提供了大量的特性，包括压缩表、空间数据索引等。     
     
    
5. 切分     
**水平切分**         
水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。        
     
**垂直切分**    
垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。     
   
6. 复制       
**主从复制**    
* binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。   
* I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。  
* SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。       
      
**读写分离**   
主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。    

7. redis 简介     
简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快 ，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。     
    






























