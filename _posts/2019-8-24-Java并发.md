---
layout:     post
title:      "Java并发"
subtitle:   ""
date:       2019-08-24 14:00:00
author:     "Cfeng"
header-img: "img/home-bg-o.jpg"
catalog: true
tags:
- Java巩固
---

## 线程和进程 
进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。   
在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。    
     
线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。     


## 实现接口 VS 继承 Thread   
实现接口会更好一些，因为：   
Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；   
类可能只要求可执行就行，继承整个 Thread 类开销过大。   
    
## 互斥同步   
** Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 _JVM_ 实现的 synchronized，而另一个是 _JDK_ 实现的 ReentrantLock。**
    
1. 新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。     
2. 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。         
3. ReentrantLock 可中断，而 synchronized 不行。      
4. 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。     
5. synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。      
6. 一个 ReentrantLock 可以同时绑定多个 Condition 对象。     
    
除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。    
     
## 线程安全   
不可变（Immutable）的对象一定是线程安全的    
synchronized 和 ReentrantLock    
CAS
乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成    
无同步方案
要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。     
        
## J.U.C - AQS   
CountDownLatch：   
用来控制一个或者多个线程等待多个线程。    
维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。    
     
CyclicBarrier：    
用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。    
和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。    
CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。     
    
Semaphore：    
Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。     
    
## 为什么要使用多线程     
**从计算机底层来说**：    
线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。    
**从当代互联网发展趋势来说**：     
现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。       
     
## 多线程的问题   
并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。    
     
## 上下文切换   
多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。      
概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换。**    
     
## 如何避免线程死锁   
> 破坏互斥条件,这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）    
> 破坏请求与保持条件,一次性申请所有的资源。   
> 破坏不剥夺条件,占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。    
> 破坏循环等待条件,靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。     
     
##  sleep() 方法和 wait() 方法    
两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。    
两者都可以暂停线程的执行。     
Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。    
wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。      
    
_new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作_    
    

## synchronized 关键字   
* synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行    

synchronized关键字最主要的三种使用方式:  
  
* **修饰实例方法**: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁    
* **修饰静态方法**: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态方法不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。    
* **修饰代码块**: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。     
         
总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！      

```java
public class Singleton {
    // 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。
    private volatile static Singleton uniqueInstance;
    private Singleton() {
    }
    public static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```    
   
## synchronized 关键字和 volatile 关键字的区别   
 _volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序_。   
        
 > 1. volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。   
 > 2. 多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞     
 > 3. volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。   
 > 4. volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。    
      
## 为什么要用线程池    
线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量     
* 降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。     
* 提高响应速度。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。     
* 提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控        
        
**实现Runnable接口和Callable接口的区别**:    
如果想让线程池执行任务的话需要实现的Runnable接口或Callable接口。 Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。两者的区别在于 Runnable 接口不会返回结果但是 Callable 接口可以返回结果。    
      
**执行execute()方法和submit()方法**     
1)execute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；    
2)submit() 方法用于提交需要返回值的任务。     

## 如何创建线程池   
1. 通过构造方法实现  ThreadPoolExecutor    
2. 通过Executor 框架的工具类Executors来实现      
>> FixedThreadPool ： 该方法返回**一个固定线程数量**的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。    
>> SingleThreadExecutor： 方法返回**一个只有一个线程**的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。     
>> CachedThreadPool： 该方法返回一个可**根据实际情况调整**线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。      
     
## 悲观锁与乐观锁   
**悲观锁**     
总是假设最坏的情况，**每次去拿数据的时候都认为别人会修改**，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。    
适用于写比较多的情况下     
     
**乐观锁**     
总是假设最好的情况，**每次去拿数据的时候都认为别人不会修改**，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。    
适用于写比较少的情况下（多读场景）   



