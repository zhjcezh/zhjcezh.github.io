----
layout:     post
title:      "数据库/mysql"
subtitle:   ""
date:       2019-08-27 14:00:00
author:     "Cfeng"
header-img: "img/home-bg-o.jpg"
catalog: true
tags:
- 数据库
---
事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚      
        
## ACID
1. 原子性（Atomicity）       
事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。         
回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。        

2. 一致性（Consistency）        
数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。       

3. 隔离性（Isolation）        
一个事务所做的修改在最终提交以前，对其它事务是不可见的。      

4. 持久性（Durability）        
一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。      
使用重做日志来保证持久性。      

* 只有满足一致性，事务的执行结果才是正确的。
* 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
* 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
* 事务满足持久化是为了能应对数据库崩溃的情况。

## 并发一致性问题    
**丢失修改**      
T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。      
    
**读脏数据**      
T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。
    
**不可重复读**    
T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。     
     
**幻影读**      
T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。    
       
产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。       
      
       
## 封锁
**封锁粒度**     
MySQL 中提供了两种封锁粒度：行级锁以及表级锁。     
应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。    
但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。    
在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。         
      
**封锁类型**       
1. 读写锁  
    * 排它锁（Exclusive），简写为 X 锁，又称写锁。    
    * 共享锁（Shared），简写为 S 锁，又称读锁。    
2. 意向锁     
意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。        
     
3. 封锁协议       
    * 三级封锁协议   
        1. 一级封锁协议: 事务 T 要修改数据 A 时必须加 **X 锁**，直到 T 结束才释放锁。       
        2. 二级封锁协议: 在一级的基础上，要求读取数据 A 时必须加 S 锁，**读取完马上释放 S 锁**   
        3. 三级封锁协议: 在二级的基础上，要求读取数据 A 时必须加 S 锁，**直到事务结束**了才能释放 S 锁。      
    
    * 两段锁协议      
    加锁和解锁分为两个阶段进行。     
    事务遵循两段锁协议是保证可串行化调度的充分条件    
    
4. Mysql隐式锁定   
MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。      
    
## 隔离级别    
未提交读（READ UNCOMMITTED）   
事务中的修改，即使没有提交，对其它事务也是可见的。     

提交读（READ COMMITTED）   
一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。      

可重复读（REPEATABLE READ）    
保证在同一个事务中多次读取同样数据的结果是一样的。     

可串行化（SERIALIZABLE）      
强制事务串行执行。需要加锁，其他通常不需要。         
    
## 多版本并发控制
多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。     
   
## Next-Key Locks
Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。     
MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。       
   
## 范式   
1. 第一范式 (1NF)
属性不可分。

2. 第二范式 (2NF)
每个非主属性完全函数依赖于键码。
可以通过分解来满足。    
    
3. 第三范式 (3NF)
   非主属性不传递函数依赖于键码。    
    
## MySQL索引
索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。      

1. B+Tree 索引  















