---
layout:     post
title:      "Java基础"
subtitle:   ""
date:       2019-08-14 14:00:00
author:     "Cfeng"
header-img: "img/home-bg-o.jpg"
catalog: true
tags:
- 学习计划
---
      
## 1.装箱拆箱   
装箱：将基本类型用它们对应的引用类型包装起来；   
拆箱：将包装类型转换为基本数据类型；     
```java   
Integer x = 2;     // 装箱  调用了 Integer.valueOf(2);   int->Integer
int y = x;         // 拆箱  调用了 Integer.intValue(x);  Integer->int
```   
     
## 2.缓冲池
基本类型对应的缓冲池如下：
> boolean values true and false   
> all byte values   
> short values between -128 and 127   
> int values between -128 and 127   
> char in the range \u0000 to \u007F   
在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。   
      
在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=<size> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。    
   
## 3.字符串   
```java    
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence,
               Constable, ConstantDesc {
    @Stable
    private final byte[] value;
    private final byte coder;
```  
String 被声明为 final，因此它不可被继承   
String 类的实现用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。    
       
**String, StringBuffer and StringBuilder**    
StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用 byte 数组存储,但是没有用 final 关键字修饰   
**线程安全性**     
String 中的对象是不可变的，也就可以理解为常量，线程安全。     
AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。　     
      
在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。    
     
## 4. 封装 继承 多态     
**封装**   
封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。    
     
**继承**
继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。   
     
1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。   
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。    
3. 子类可以用自己的方式实现父类的方法。（以后介绍）。      
      
> 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。    
> 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。    
> 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。      
> 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。    
> 备注：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。    

**多态**
所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。   
     
在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。    

## 5.static    
在一个静态方法内调用一个非静态成员为什么是非法的?     
由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。    
     
静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。     
静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。    
静态语句块在类初始化时运行一次。     
     
## 6.异常   
Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误。    
Exception 分为两种：    
> 受检异常 ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复   
> 非受检异常 ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。     

## 7.泛型   
提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException     
Array事实上并不支持泛型    
Java：   
```java
List<Integer>[] genericArray = (List<Integer>[])new ArrayList[10];
```
Java虽然禁止直接创建泛型数组实例，但并没有禁止声明一个泛型数组引用    
虽然编译期不会报错，但是这样做仍然有潜在的风险，因为类型擦除的存在      
类型擦出：简单来说Java在编译期间，所有的泛型信息都会被擦除掉。   
如在代码中定义的List<object>和List<String>等类型，在编译后都会变成List。    

## 8.注解    
用处：    
1、生成文档。这是最常见的，也是java 最早提供的注解。常用的有@param @return 等   
2、跟踪代码依赖性，实现替代配置文件功能。比如Dagger 2 依赖注入，未来java 开发，将大量注解配置，具有很大用处;    
3、在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。   

原理：   
注解本质是一个继承了Annotation 的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池。    

## 9.Java 与 C++ 的区别   
* Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。   
* Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。   
* Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。   
* Java 支持自动垃圾回收，而 C++ 需要手动回收。   
* Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。   
* Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。   
* Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。   
* Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。     
    
## 10.Cookie和Session的的区别    
Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。     

Cookie 一般用来保存用户信息 比如我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；登录一次网站后访问网站其他页面不需要重新登录。    
Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。    
    
Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。  
    
Cookie 存储在客户端中，而Session 存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。  
     
## 11.转发(Forward)和重定向(Redirect)的区别    
**转发是服务器行为，重定向是客户端行为。**  
forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等      
forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据.     
forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.     

## 12.Servlet    
一个Servlet可以设置多个URL访问    
Servlet不是线程安全      
Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。     
JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。     
Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。   

## 常见问题：
**面向对象和面向过程的区别：**    
面向过程 ：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。  
面向对象 ：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低    
     
**JVM JDK JRE：**  
JVM：Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。    
JDK：Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。     
JRE：Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。     
     
**API SKD：**   
API：“应用程序编程接口”，是一些预先定义的函数，目的是作为“介面”沟通两个不同的东西，提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。    
SDK：“软体开发工具包”，一般是一些被软件工程师用于为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件的开发工具的集合。通俗点是指由第三方服务商提供的实现软件产品某项功能的工具包。    
    
SDK相当于开发集成工具环境，API就是数据接口。在SDK环境下调用API数据。   
    
**成员变量与局部变量的区别**  
1. 成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，**成员变量和局部变量都能被 final 所修饰**。  
2. 如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。     
3. 成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。    
4. 成员变量会被赋类型的默认值为初值，局部变量不会     
     
**== 和 equals**  
==: 它的作用是判断两个对象的**地址**是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。    
equals() :
> 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。     
> 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。    
     
**hashCode（）与equals（）的相关规定**   
1. 如果两个对象相等，则hashcode一定也是相同的  
2. 两个对象相等,对两个对象分别调用equals方法都返回true  
3. 两个对象有相同的hashcode值，它们也不一定是相等的  
4. 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖  
5. hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）  
    

