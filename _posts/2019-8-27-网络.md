---
layout:     post
title:      "计算机网络复习"
subtitle:   ""
date:       2019-08-27 14:00:00
author:     "Cfeng"
header-img: "img/home-bg-o.jpg"
catalog: true
tags:
- 计算机网络
---
**_网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。_**    
     
## 主机之间的通信方式
* 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。    
* 对等（P2P）：不区分客户和服务器。         

## 计算机网络体系结构
1. 五层协议      
    * 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。     
    * 传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。     
    * 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。     
    * 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。    
    * 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。    

传输层最主要的协议是TCP和UDP协议，网络层最重要的协议是IP协议。  
           
2. TCP/IP    
它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。     
TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。       
   
## 物理层   

物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性    

**通信方式:**    
根据信息在传输线上的传送方向，分为以下三种通信方式:  
* 单工通信：单向传输     
* 半双工通信：双向交替传输   
* 全双工通信：双向同时传输    
     
**带通调制**    
模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。     

## 数据链路层     
1. 封装成帧：将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。      
2. 透明传输：透明表示一个实际存在的事物看起来好像不存在一样。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在            
3. 差错检测：目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。     
      
**信道分类:**          
1. 广播信道:一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。为避免发生冲突（冲突也叫碰撞），主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。        
2. 点对点信道:一对一通信。因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制           
        
**信道复用技术**     
1. 频分复用：频分复用的所有主机在相同的时间占用不同的频率带宽资源。        
2. 时分复用：时分复用的所有主机在不同的时间占用相同的频率带宽资源。                 
3. 统计时分复用：是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。      
      
**CSMA/CD 协议**      
CSMA/CD 表示载波监听多点接入 / 碰撞检测。    
    
* 多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。
* 载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。
* 碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。
     
记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。     
当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。     

**MAC 地址**     
MAC 地址是链路层地址，长度为 6 字节（48 位），用于**唯一标识网络适配器**（网卡）。     
一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。          
      
## 网络层       
因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。      
使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。       
与 IP 协议配套使用的还有三个协议：    
* 地址解析协议 ARP（Address Resolution Protocol）       
* 网际控制报文协议 ICMP（Internet Control Message Protocol）    
* 网际组管理协议 IGMP（Internet Group Management Protocol）           
       
## 传输层   
**UDP 和 TCP 的特点**    
用户数据报协议 UDP（User Datagram Protocol）是**无连接**的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持**一对一、一对多、多对一和多对多**的交互通信。    

传输控制协议 TCP（Transmission Control Protocol）是**面向连接**的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接**只能是点对点**的（一对一）。           
       
## TCP 的三次握手     
假设 A 为客户端，B 为服务器端。
    
1. 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。   
2. A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。    
3. B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。   
4. A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。   
5. B 收到 A 的确认后，连接建立。    
     
三次握手的原因：
**三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。**   
第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。    

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

## TCP 的四次挥手    
* A 发送连接释放报文，FIN=1。     
* B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。         
* 当 B 不再需要连接时，发送连接释放报文，FIN=1。      
* A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。    
* B 收到 A 的确认后释放连接。      
      
四次挥手的原因：

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了**让服务器端发送还未传送完毕的数据**，传送完毕之后，服务器会发送 FIN 连接释放报文。     
      
举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。              
       
## TCP,UDP 协议的区别    
UDP 在传送数据之前**不需要先建立连接**，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（**一般用于即时通信**），比如： QQ 语音、 QQ 视频 、直播等等     

TCP 提供**面向连接**的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务，这一难以避免**增加了许多开销**，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。            


## TCP 协议如何保证可靠传输    
1. 应用数据被分割成 TCP 认为最适合发送的数据块。        
2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。                
3. 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。            
4. TCP 的接收端会丢弃重复的数据。           
5. 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）        
6. 拥塞控制： 当网络拥塞时，减少数据的发送。           
7. ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。         
8. 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。          

## 在浏览器中输入url地址 ->> 显示主页的过程    
1. DNS解析------网址到IP地址的转换    
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束


## HTTP 状态码
服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。

|状态码	|类别	|含义|
|  :----:  | :----:  |
|1XX|	Informational（信息性状态码）|	接收的请求正在处理|
|2XX|	Success（成功状态码）	|请求正常处理完毕|
|3XX|	Redirection（重定向状态码）	|需要进行附加操作以完成请求|
|4XX|	Client Error（客户端错误状态码）	|服务器无法处理请求|
|5XX|	Server Error（服务器错误状态码）	|服务器处理请求出错|


## HTTP是不保存状态的协议,如何保存用户状态   
HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。    

在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。        

**Cookie 被禁用怎么办?**      
最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。   

**Cookie 与 Session 选择**   
Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；  
Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；  
对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。    


## HTTP 和 HTTPS 的区别？
1. 端口 ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。   
2. 安全性和资源消耗： HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。   

        
对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；     
非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。   

## HTTP 方法    
* GET  
* HEAD  
* POST  
* PUT  
* PATCH  
* DELETE  
* OPTIONS  
* CONNECT  
* TRACE  