---
layout:     post
title:      "一些多线程的总结"
subtitle:   ""
date:       2019-03-14 14:00:00
author:     "Cfeng"
header-img: "img/post-bg-universe.jpg"
catalog: true
tags:
    - 多线程
    - 操作系统
---

# 线程与进程的概念与区别

线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的**多个线程共享同一块内存空间和一组系统资源**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是**静态的代码**。

进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。

线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。

线程上下文的切换比进程上下文切换要快很多
* 进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。
* 线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。

# 线程的基本状态
1. 新建(new)：新创建了一个线程对象。
2. 就绪(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。
3. 运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。
4. 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入就绪(runnable)态，才有机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：
(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waiting queue)中。
(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
(三). 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。
5. 退出(dead)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

# 多线程
多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。
1. 使用线程可以把占据长时间的程序中的任务放到后台去处理。
2. 程序的运行速度可能加快。

## 继承Runnable接口
推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。
```
MyRunnable.java
public class MyRunnable implements Runnable {
	@Override
	public void run() {
		System.out.println("MyRunnable");
	}
}
Run.java
public class Run {
	public static void main(String[] args) {
		Runnable runnable=new MyRunnable();
		Thread thread=new Thread(runnable);
		thread.start();
		for(int i=1;i<=10;i++){
            System.out.println("运行结束！");
        }
	}
}
运行结果：
/*
运行结束！
运行结束！
运行结束！
运行结束！
运行结束！
运行结束！
运行结束！
MyRunnable
运行结束！
运行结束！
运行结束！
*/
```

## 使用线程池
* 线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。
使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。

* 制线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险
---
Executors 返回线程池对象的弊端如下：
FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。
CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。
---
*OOM，全称“Out Of Memory”，翻译成中文就是“内存用完了”*

# 线程的优先级
每个线程都具有各自的优先级，线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态。但这个并不意味着低优先级的线程得不到运行，而只是它运行的几率比较小，如**垃圾回收机制线程**的优先级就比较低。所以很多垃圾得不到及时的回收处理。

线程优先级具有**继承特性**。 比如A线程启动B线程，则B线程的优先级和A是一样的。

线程优先级具有**随机性**。 也就是说线程优先级高的不一定每一次都先执行完。

Thread类中包含的成员变量代表了线程的某些优先级。如Thread.MIN_PRIORITY（常数1），Thread.NORM_PRIORITY（常数5）, Thread.MAX_PRIORITY（常数10）。其中每个线程的优先级都在Thread.MIN_PRIORITY（常数1） 到Thread.MAX_PRIORITY（常数10） 之间，在默认情况下优先级都是Thread.NORM_PRIORITY（常数5）。
*1最低，10最高*

# 用户线程
* 运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程

# 守护线程
运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 “佣人”。

特点： 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作
应用： 数据库连接池中的检测线程，JVM虚拟机启动后的检测线程
最常见的守护线程： 垃圾回收线程
可以通过调用 Thead 类的 setDaemon(true) 方法设置当前的线程为守护线程。

注意事项：
1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常
2. 在守护线程中产生的新线程也是守护线程
3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑

# sleep()与wait()
* 两者最主要的区别在于：sleep方法没有释放锁，而wait方法释放了锁 。
* 两者都可以暂停线程的执行。
* Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。
* wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。

# 调用了start()，而不是run()
new一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工
